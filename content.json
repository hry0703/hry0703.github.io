{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"发布-订阅模式","slug":"发布-订阅模式","date":"2021-03-08T07:07:21.000Z","updated":"2021-08-08T07:59:54.146Z","comments":true,"path":"2021/03/08/发布-订阅模式/","link":"","permalink":"http://example.com/2021/03/08/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"发布/订阅模式(Publish/Subscribe Pattern)1. 什么是发布订阅模式 发布-订阅模式里面包含了三个模块，发布者，订阅者和调度中心。订阅者把自己想订阅的事件注册到调度中心，当发布者发布该事件）到调度中心，也就是该事件触发时，由调度中心统一调度订阅者注册到调度中心的处理代码。 2. 发布订阅模式与观察者模式的区别 观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰，消除了发布者和订阅者之间的依赖。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。 3. 发布订阅模式应用-node中Event模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// event.js function EventEmitter()&#123; this._events = &#123;&#125;&#125;EventEmitter.prototype.on = function (eventName, callback)&#123; if(!this._events) this._events = &#123;&#125; const callbacks = this._events[eventName] || []; callbacks.push(callback) this._events[eventName] = callbacks&#125;EventEmitter.prototype.emit = function(eventName, ...args) &#123; if (!this._events) this._events = &#123;&#125; let callbacks = this._events[eventName]; callbacks &amp;&amp; callbacks.forEach(fn=&gt;fn(...args))&#125;EventEmitter.prototype.off = function(eventName, callback) &#123; if (!this._events) this._events = &#123;&#125; this._events[eventName] &amp;&amp; this._events[eventName].filter(fn =&gt; fn !== callback &amp;&amp; fn.l !== callback)&#125;EventEmitter.prototype.once = function (eventName, callback) &#123; const one = (...args)=&gt;&#123; callback(...args) this.off(eventName,one) &#125; one.l = callback // 建立与原回调的关联 this.on(eventName,one)&#125;module.exports = EventEmitter// 具体使用// const EventEmitter = require(&#x27;events&#x27;);const EventEmitter = require(&#x27;./event&#x27;);const events = new EventEmitterconst getUp = function(name)&#123; console.log(name + &#x27;起床了&#x27;)&#125;events.on(&#x27;getUp&#x27;, getUp)events.emit(&#x27;getUp&#x27;, &#x27;zhangsan&#x27;)events.off(&#x27;getUp&#x27;, getUp)events.emit(&#x27;getUp&#x27;, &#x27;zhangsan&#x27;)","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"linux文件路径操作","slug":"linux文件路径操作","date":"2020-05-03T03:23:25.000Z","updated":"2021-08-01T22:49:46.760Z","comments":true,"path":"2020/05/03/linux文件路径操作/","link":"","permalink":"http://example.com/2020/05/03/linux%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Linux 常用命令系统信息arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销 文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行sed -e ‘s/ $//‘ example.txt 删除每一行最后的空白字符sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s/00/0/g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"reactAPI","slug":"ReactAPI","date":"2020-05-03T03:14:37.000Z","updated":"2021-08-01T22:49:46.758Z","comments":true,"path":"2020/05/03/ReactAPI/","link":"","permalink":"http://example.com/2020/05/03/ReactAPI/","excerpt":"","text":"memomemo 用来对函数组件进行缓存，父组件传的props未改变时，不会重新渲染该子组件，与class组件的PureComponent类似，默认情况下其只会对复杂对象做浅层对比，可以传递一个对比函数作为第二个参数，来进行深层次的对比。 1234567891011function MyComponent(props) &#123; /* 使用 props 渲染 */&#125;function areEqual(prevProps, nextProps) &#123; /* 如果把 nextProps 传入 render 方法的返回结果与 将 prevProps 传入 render 方法的返回结果一致则返回 true， 否则返回 false */&#125;export default React.memo(MyComponent, areEqual); 举个例子： 12345678910111213141516171819202122232425262728293031// 点击Re-render不会引起ReactMemo组件的重新渲染// 子组件import React, &#123; memo &#125; from &#x27;react&#x27;function ReactMemo(props)&#123; console.log(&#x27;ReactMemo渲染了&#x27;) return ( &lt;&gt; &lt;div&gt; &#123;`我是props的值:$&#123;props.flag&#125;`&#125; &lt;/div&gt; &lt;/&gt; )&#125;export default memo(ReactMemo)// 父组件import React, &#123; useState &#125; from &#x27;react&#x27;;import ReactMemo from &#x27;../ReactMemo/ReactMemo&#x27;export default function Home ()&#123; const [random, setRandom] = useState(Math.random()); const [mounted, setMounted] = useState(true); // 这个函数改变 random，并触发重新渲染 const reRender = () =&gt; setRandom(Math.random()); const toggle = () =&gt; setMounted(!mounted); return ( &lt;&gt; &lt;button onClick=&#123;reRender&#125;&gt;Re-render&lt;/button&gt; &lt;button onClick=&#123;toggle&#125;&gt;switch&lt;/button&gt; &lt;ReactMemo flag=&#123;mounted&#125;&gt;&lt;/ReactMemo&gt; &lt;/&gt; );&#125; 子组件接收方法的情况下，需要配合useCallback 将函数缓存才能真正做到子组件的缓存","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"reactHooks","slug":"ReactHooks","date":"2020-05-03T03:11:45.000Z","updated":"2021-08-01T22:49:46.759Z","comments":true,"path":"2020/05/03/ReactHooks/","link":"","permalink":"http://example.com/2020/05/03/ReactHooks/","excerpt":"","text":"副作用：React 中主要指那些没有发生在数据向视图（M-V）转换过程中的逻辑，如 Ajax 请求、访问原生 DOM 元素、本地持久化缓存、绑定/解绑事件、添加/取消订阅、设置定时器、记录日志等。 Hooks 的优越性： 函数式编程：No class, No super, No this。对于不了解 OOP 的 React 初学者更友好。 有状态逻辑易复用：可以通过 Custom Hook（后面讲解）重构，而不用修改组件结构。 易拆分：状态管理和副作用管理松耦合，原子性强。很容易将一些相关联的逻辑拆分成更小的函数。 可逐步引入：Hooks 向后兼容，与现有代码可并行工作，因此我们可以逐步采用它们。 副作用分组：很多副作用逻辑分散在类组件生命周期函数中。而 Hooks 可以将每个副作用的设置和清理封装在一个函数中。 副作用分离：副作用操作都在页面渲染之后。 useStateuseState用来声明状态变量。接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第[0]项是当前当前的状态值，第[1]项是可以改变状态值的方法函数。 12345const [count, setCount] = useState(0);// 如果不用es6解构写法就得这么写：let _useState = useState(0);let count = _useState[0];let setCount = _useState[1]; useState是按照书写顺序执行的，因此为了保证执行顺序一致。useState不能书写在if else 等判断逻辑中 1234567// 错误写法let flag = falseif(!flag)&#123; const [loading,setLoading] = useState(false) flag = true&#125; const [datalist,setDataList] = useState([]) useState「粒度」问题实际工作中，一个类组件的 this.state 中往往有十几项，用 Hooks 改写的话要写十几个 useState根据官方文档，总结下来，有几点： 建议将 state 分割为多个 useState。粒度更细，更易于管理，更好复用。 可能一起改变的 state 可合并成一个useState（ 比如Dom元素的 top left）。 当 state 逻辑趋于复杂，建议使用 reducer 或 Custom Hook 管理（后面介绍）。 当组件的 state 很多的时候，为了提高代码的可读性，也可以把逻辑相关的一些 state 合并为一个 useState（ 比如分页参数 ）。但这些 state 并不是一起改变的，所以当其中一个 state 改变，调用对应的 setFunction 的时候。你需要做对象合并(不合并就丢了)： 1234567const [ pageData, setPageDate ] = useState(&#123; pageSize: 20, current: 1, total:0, &#125;)const onPageChange = current =&gt; &#123; // 常规操作 setPageDate( Object.assign( &#123;&#125;, pageData, &#123; current &#125; ) ） // 官方建议 setPageDate(currentPageData =&gt; (&#123; ...currentPageData, current&#125;));&#125; useEffectuseEffect在第一次渲染之后和每次更新之后都会执行。也可以通过第二个参数来控制是否执行，React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。effects 的心理模型跟 componentDidMount 和其他的生命周期是不同的。应该用 effects 的方式去思考，而且比起回应生命周期事件，它的心理模型更接近於執行同步化 12345useEffect(() =&gt; &#123; return ()=&gt;&#123; // 组件卸载之前执行 需要做副作用的清理，保证引起不必要内存泄漏。比如，手动绑定事件，订阅，定时器等。 &#125; &#125;,[]); 1234567891011121314151617181920212223242526272829303132333435363738// child组件import React, &#123; useState,useEffect &#125; from &#x27;react&#x27;;export default function Child ()&#123; const [count, setCount] = useState(0) useEffect(() =&gt; &#123; console.log(`mount:$&#123;count&#125;`); return ()=&gt;&#123; console.log(`unmount:$&#123;count&#125;`); &#125; &#125;); return ( &lt;&gt; &lt;p&gt;I&#x27;m a lifecycle demo&lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123;setCount(count + 1)&#125;&#125;&gt;add&lt;/button&gt; &lt;div&gt; &#123;count&#125; &lt;/div&gt; &lt;/&gt; );&#125;// home组件import React, &#123; useState,useEffect &#125; from &#x27;react&#x27;;import &#x27;./Home.scss&#x27;;import Child from &#x27;../Child/Child&#x27;export default function Home ()&#123; // 建立一个状态来切换 LifecycleDemo 的显示和隐藏 const [mounted, setMounted] = useState(true); // 该函数将卸载并重新挂载 LifecycleDemo // 在控制台可以看到 unmount 被打印 const toggle = () =&gt; setMounted(!mounted); return ( &lt;&gt; &lt;button onClick=&#123;toggle&#125;&gt;Show/Hide LifecycleDemo&lt;/button&gt; &#123;mounted &amp;&amp; &lt;Child/&gt;&#125; &lt;/&gt; );&#125; 控制useEffect 的执行useEffect(fn, []),第二个参数是个数组，传递的是该useEffect的依赖项。当传递进去的依赖项变动时，该useEffect会重新执行。注意： 不传第二个参数，则其他不相关数据变动引起的组件重新渲染时也会重新执行该useEffect； 第二个参数为空数组，表示没有依赖项，该useEffect在组件首次渲染时执行和组件卸载时执行清除副作用之后就不会再执行，（诚实传递依赖项，不要漏写，以免引起未知问题）； 与 componentDidMount 和 componentDidUpdate 的区别使用 useEffect 调度的副作用不会阻塞浏览器更新屏幕。这使得应用感觉上具有响应式。大多数副作用不需要同步发生。如果需要同步进行，（比如测量布局），有一个单独的 useLayoutEffect Hook， API 和 useEffect 相同。 知识点：调用 useState 的更新函数时，可以传一个箭头函数，这个函数的参数是当前最新的 state， 返回值是要设置的 state,可以配合useEffect使用，来减少useEffect的依赖项。 123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;function App() &#123; // 秒表开关 const [isOn, setIsOn] = useState(false); // 计数 const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; //开关打开的时候才执行 if (isOn) &#123; // 通过定时器增加计数 interval = setInterval( () =&gt; setTimer(timer + 1), // 这里每次需要获取定时器每次的最新值，所以这种写法，useEffect必须添加timer为依赖项 // () =&gt; setTimer(val =&gt; val + 1),// 用箭头函数的方式，参数就是最新的定时器值，这种写法可以减少依赖项，较优 1000, ); &#125; // 需要清除定时器 // 不清理会如何？codesandbox中尝试，页面直接卡死 return () =&gt; clearInterval(interval); &#125;,[isOn,timer]); return ( &lt;&gt; &lt;p&gt;&#123;timer&#125;&lt;/p&gt; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/&gt; );&#125;export default App; 实际项目中axios的使用useEffect 不能接收 async 作为执行函数。useEffect 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 async 返回的是 promise。useEffect 调用的函数如果依赖 state 或者 props。最好在执行函数中定义。这样依赖容易追踪。 12345678910111213141516171819202122232425import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;import axios from &#x27;axios&#x27;;function App() &#123; const [data, setData] = useState([]); useEffect(() =&gt; &#123; // 更优雅的方式 const fetchData = async () =&gt; &#123; const result = await axios( &#x27;https://hn.algolia.com/api/v1/search?query=redux&#x27;, ); setData(result.data); &#125;; fetchData(); &#125;, []); return ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default App; useContext多级嵌套组件之间共享状态，可以使用useContext。 123456789101112131415161718192021222324252627282930import React, &#123; useContext&#125; from &#x27;react&#x27;;const data = &#123; age:118, action:function()&#123; console.log(&#x27;this is action&#x27;) &#125;,&#125;const dataContext = React.createContext(data.age); // 1.export default function ContextCo ()&#123; return ( // 2. &lt;dataContext.Provider value=&#123;data.age&#125;&gt; &lt;Son /&gt; &lt;/dataContext.Provider&gt; );&#125;function Son()&#123; return ( &lt;GraSon&gt; &lt;/GraSon&gt; )&#125;function GraSon()&#123; const data = useContext(dataContext); // 3. console.log(data) // 118 return ( &lt;&gt; this is GraSon &lt;/&gt; )&#125; useRefuseRef 不仅仅是用来管理 DOM ref 的(场景一)，同时也会用来存放组件实例的属性（场景三）。useRef 返回一个可变的ref对象，其.current属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变,是相同的引用（createRef 每次渲染都会返回一个新的引用）,因此 useRef 的内容发生变化时,它不会通知您。更改.current属性不会导致重新呈现。 因为他一直是一个引用。 123456789101112131415// 场景一：import &#123; useRef &#125; from &#x27;react&#x27;;export default function Home ()&#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); // input框聚焦 &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125; useRef可以获取到实时状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 场景二：点击lert按钮时的count值，是点击alert动作触发时的count值快照，不是定时器触发后的实时值，import React, &#123; useState,useEffect &#125; from &#x27;react&#x27;;export default function Child ()&#123; const [count, setCount] = useState(0) const log = ()=&gt;&#123; setTimeout(()=&gt;&#123; console.log(count); &#125;,3000) &#125; return ( &lt;&gt; &lt;p&gt;计时器 &lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123;setCount(count + 1)&#125;&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;log&#125;&gt;print&lt;/button&gt; &lt;div&gt; &#123;count&#125; &lt;/div&gt; &lt;/&gt; );&#125;// 上述场景如何取到定时器触发时实时的状态？ 需要使用uesRef// 场景三：import React, &#123; useState, useEffect, useRef &#125; from &#x27;react&#x27;;export default function Child ()&#123; const [count, setCount] = useState(0) const latestCount = useRef(count) useEffect(()=&gt;&#123; latestCount.current = count &#125;) const log = ()=&gt;&#123; setTimeout(()=&gt;&#123; console.log(latestCount.current); &#125;,3000) &#125; return ( &lt;&gt; &lt;p&gt;计时器 &lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123;setCount(count + 1)&#125;&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;log&#125;&gt;print&lt;/button&gt; &lt;div&gt; &#123;count&#125; &lt;/div&gt; &lt;/&gt; );&#125; useMemouseMemo返回的是数据，用来缓存数据，当 组件内部某一个渲染的数据，需要通过计算而来，这个计算是依赖与特定的state、props数据，我们就用useMemo来缓存这个数据，以至于我们在修改她们没有依赖的数据源的情况下，多次调用这个计算函数，浪费计算资源。 1234567891011121314151617181920212223242526272829303132333435import React, &#123; useState, useEffect, useRef, useMemo,useCallback &#125; from &#x27;react&#x27;;export default function ReactUseCallback ()&#123; const [gender,setGender] = useState(&#x27;male&#x27;) const [count, setCount] = useState(0) const latestCount = useRef(count) useEffect(()=&gt;&#123; latestCount.current = count &#125;) const log = ()=&gt;&#123; setTimeout(()=&gt;&#123; console.log(latestCount.current); &#125;,3000) &#125; function judgeGender(gender)&#123; console.log(&#x27;这里是判断性别的方法&#x27;) return gender === &#x27;male&#x27; ? &quot;男&quot;:&quot;女&quot; &#125; // let showGender = judgeGender(gender) // 这种写法，count修改时，judgeGender方法也会重复调用 let showGender = useMemo(()=&gt;&#123; // 依赖项gender不改变则不会重复执行judgeGender方法 return judgeGender(gender) &#125;,[gender]) const change = ()=&gt;&#123; console.log(&#x27;我是父组件传递的方法&#x27;) &#125; return ( &lt;&gt; &lt;p&gt;计时器 &lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123;setCount(count + 1)&#125;&#125;&gt;add&lt;/button&gt; &lt;p&gt;当前次数：&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;log&#125;&gt;print&lt;/button&gt; &lt;button onClick=&#123;()=&gt;setGender(&#x27;female&#x27;)&#125;&gt;修改性别&lt;/button&gt; &lt;p&gt;这里显示性别：&#123;showGender&#125;&lt;/p&gt; &lt;/&gt; );&#125; useCallback缓存一个函数，这个函数如果是由父组件传递给子组件，或者自定义hooks里面的函数【通常自定义hooks里面的函数，不会依赖于引用它的组件里面的数据】，这时候我们可以考虑缓存这个函数，好处： 1，不用每次重新声明新的函数，避免释放内存、分配内存的计算资源浪费2，子组件不会因为这个函数的变动重新渲染。(和React.memo搭配使用) useReduceruseImperativeHandleCustom Hooks自定义 Hook 是一个 JavaScript 函数，其名称以 ”use” 开头，可以调用其他 HookCustom Hooks 将解决有状态（stateful）逻辑共享的问题（相当于类组件中Hoc的功能）下面是判断设备是否离线的自定义hook: 1234567891011121314151617181920212223242526272829303132333435import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;// 自定义 hookfunction useOffline() &#123; const [isOffline, setIsOffline] = useState(window.navigator.onLine); function onOffline() &#123; setIsOffline(true); &#125; function onOnline() &#123; setIsOffline(false); &#125; useEffect(() =&gt; &#123; window.addEventListener(&#x27;offline&#x27;, onOffline); window.addEventListener(&#x27;online&#x27;, onOnline); return () =&gt; &#123; window.removeEventListener(&#x27;offline&#x27;, onOffline); window.removeEventListener(&#x27;online&#x27;, onOnline); &#125;; &#125;, []); return isOffline; // 只暴露一个 state&#125;// 函数组件function App() &#123; const isOffline = useOffline(); return ( &lt;&gt; &#123; isOffline ? &lt;div&gt;网断已断开 ...&lt;/div&gt; : &lt;div&gt;网络已连接 ...&lt;/div&gt; &#125; &lt;/&gt; )&#125;export default App;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]}],"categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]}