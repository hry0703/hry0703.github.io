<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-javascript-原型链" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/02/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="article-date">
  <time class="dt-published" datetime="2021-08-01T22:51:46.000Z" itemprop="datePublished">2021-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/02/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/">javascript 原型链</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="javascript-原型链与继承"><a href="#javascript-原型链与继承" class="headerlink" title="javascript 原型链与继承"></a>javascript 原型链与继承</h2><h3 id="es5-构造函数"><a href="#es5-构造函数" class="headerlink" title="es5 构造函数"></a>es5 构造函数</h3><h4 id="继承（三种）"><a href="#继承（三种）" class="headerlink" title="继承（三种）"></a>继承（三种）</h4><p>公有属性 私有属性 静态方法（静态属性）的继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数中的this，通过new调用则this指代的是实例</span></span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>  <span class="comment">// 私有属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有属性</span></span><br><span class="line">    Parent.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">9</span> </span><br><span class="line">        <span class="comment">// 1. 仅继承私有属性 </span></span><br><span class="line">        Parent.call(<span class="built_in">this</span>) <span class="comment">// 继承Parent类上的私有属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Child.prototype.smoking = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;吸烟&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 仅继承公有属性</span></span><br><span class="line">    <span class="comment">// 1) Child.prototype.__proto__ = Parent.prototype </span></span><br><span class="line">    <span class="comment">// Object.setPrototype(Child.prototype,Parent.prototype) 1的es6写法</span></span><br><span class="line">    <span class="comment">// 2) Child.prototype = Object.create(Parent.prototype，&#123;constructor:&#123;value:Child&#125;&#125;)只继承公有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object.create的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">parentPrototype,props</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">        Fn.prototype = parentPrototype</span><br><span class="line">        <span class="keyword">let</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> props)&#123;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(fn,key,&#123;</span><br><span class="line">                ...props[key],</span><br><span class="line">                <span class="attr">enumerable</span>:<span class="literal">true</span></span><br><span class="line">            &#125;)    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">return</span> fn</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line">    <span class="keyword">let</span> child = <span class="keyword">new</span> Child()</span><br><span class="line">    child.eat() <span class="comment">// 可以继承到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误方法1：实质是将子类原型替换为父类原型 再添加原型属性相当于在父类上添加原型属性</span></span><br><span class="line">    <span class="comment">// Child.prototype = Parent.prototype </span></span><br><span class="line">    <span class="comment">// Child.prototype.a = 100 </span></span><br><span class="line">    <span class="comment">// let parent = new Parent()</span></span><br><span class="line">    <span class="comment">// console.log(parent.a) // 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 继承公有属性和私有属性</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()  <span class="comment">// 不会使用这种方式，既继承了父类的公有又有私有属性</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<!-- http://www.javascriptpeixun.cn/course/3158/task/196220/show -->

<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">        <span class="comment">// return &#123; a: 1 &#125;  // console.log(child)  &#123; a: 1, age: 9 &#125;   并且执行child.eat()时会报错 child.eat is not a function</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;parent b&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;parent eat&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;  <span class="comment">// 继承私有和公有 </span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>() <span class="comment">// Parent.call(this)</span></span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;child a&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">smoking</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child()</span><br><span class="line">child.eat()  <span class="comment">// 子类实例继承了父类的公有方法</span></span><br><span class="line"><span class="built_in">console</span>.log(child.name)  <span class="comment">//  子类实例继承了父类实例的私有属性</span></span><br><span class="line">Child.b()  <span class="comment">// 子类继承了父类的静态方法</span></span><br></pre></td></tr></table></figure>

<ol>
<li>类只能new </li>
<li>类可以继承公有私有和静态方法</li>
<li>父类的构造函数中返回了一个引用类型会把这个引用类型作为子类的this </li>
</ol>
<p>、、、javascript</p>
<!-- 类的编译 -->
<p>```</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/02/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/" data-id="cks2wsell0005cws52567a4rm" data-title="javascript 原型链" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/02/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-08-01T22:49:46.759Z" itemprop="datePublished">2021-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/02/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/02/hello-world/" data-id="ckq3ffjm40001wss5aivf3gkp" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-发布-订阅模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/08/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-03-08T07:07:21.000Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/08/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">发布-订阅模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="发布-订阅模式-Publish-Subscribe-Pattern"><a href="#发布-订阅模式-Publish-Subscribe-Pattern" class="headerlink" title="发布/订阅模式(Publish/Subscribe Pattern)"></a>发布/订阅模式(Publish/Subscribe Pattern)</h2><h3 id="1-什么是发布订阅模式"><a href="#1-什么是发布订阅模式" class="headerlink" title="1. 什么是发布订阅模式"></a><strong>1. 什么是发布订阅模式</strong></h3><p>   发布-订阅模式里面包含了三个模块，发布者，订阅者和调度中心。订阅者把自己想订阅的事件注册到调度中心，当发布者发布该事件）到调度中心，也就是该事件触发时，由调度中心统一调度订阅者注册到调度中心的处理代码。</p>
<p><img src="./publish-subscribe.png" alt="发布/订阅模式"></p>
<h3 id="2-发布订阅模式与观察者模式的区别"><a href="#2-发布订阅模式与观察者模式的区别" class="headerlink" title="2. 发布订阅模式与观察者模式的区别"></a><strong>2. 发布订阅模式与观察者模式的区别</strong></h3><p>   观察者模式和发布订阅模式最大的区别就是发布订阅模式有个<strong>事件调度中心</strong>。观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰，消除了发布者和订阅者之间的依赖。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。</p>
<h3 id="3-发布订阅模式应用-node中Event模块"><a href="#3-发布订阅模式应用-node中Event模块" class="headerlink" title="3. 发布订阅模式应用-node中Event模块"></a><strong>3. 发布订阅模式应用-node中Event模块</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event.js </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._events = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>._events) <span class="built_in">this</span>._events = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> callbacks = <span class="built_in">this</span>._events[eventName] || [];</span><br><span class="line">    callbacks.push(callback)</span><br><span class="line">    <span class="built_in">this</span>._events[eventName] = callbacks</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._events) <span class="built_in">this</span>._events = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>._events[eventName];</span><br><span class="line">    callbacks &amp;&amp; callbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn(...args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.off = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._events) <span class="built_in">this</span>._events = &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>._events[eventName] &amp;&amp; <span class="built_in">this</span>._events[eventName].filter(<span class="function"><span class="params">fn</span> =&gt;</span> fn !== callback &amp;&amp; fn.l !== callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> one = <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">        callback(...args)</span><br><span class="line">        <span class="built_in">this</span>.off(eventName,one)</span><br><span class="line">    &#125;</span><br><span class="line">    one.l = callback <span class="comment">// 建立与原回调的关联</span></span><br><span class="line">    <span class="built_in">this</span>.on(eventName,one)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line"><span class="comment">// const EventEmitter = require(&#x27;events&#x27;);</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;./event&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> events = <span class="keyword">new</span> EventEmitter</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUp = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name + <span class="string">&#x27;起床了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">events.on(<span class="string">&#x27;getUp&#x27;</span>, getUp)</span><br><span class="line"></span><br><span class="line">events.emit(<span class="string">&#x27;getUp&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">events.off(<span class="string">&#x27;getUp&#x27;</span>, getUp)</span><br><span class="line">events.emit(<span class="string">&#x27;getUp&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/08/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" data-id="cks2wselq000ccws5896ng7ha" data-title="发布-订阅模式" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux文件路径操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/03/linux%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T03:23:25.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/03/linux%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C/">linux文件路径操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS </p>
<h2 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h2><p>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销 </p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)   </p>
<h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径 </p>
<h2 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h2><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p>
<h2 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h2><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p>
<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><p>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><p>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/03/linux%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C/" data-id="cks2wselo0008cws52gqyfiql" data-title="linux文件路径操作" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-typescript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/03/typescript/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T03:21:40.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/03/typescript/">typescript</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>typescript 语法入门</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag : <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num : <span class="built_in">number</span> = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>1 . 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName : <span class="built_in">string</span>  = <span class="string">&#x27;huang&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>2 . 使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围 ``，并且以${ expr }这种形式嵌入表达式</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age : <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> firstName : <span class="built_in">string</span>  = <span class="string">&#x27;huang&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lineBreak : <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; firstName &#125;</span>.</span></span><br><span class="line"><span class="string">I&#x27;ll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>ts中数组会区分类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1 字符串类型的数组  两种写法</span></span><br><span class="line"><span class="keyword">let</span> pets1: <span class="built_in">string</span>[] = [<span class="string">&quot;旺财&quot;</span>, <span class="string">&quot;小白&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> pets2: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;旺财&quot;</span>, <span class="string">&quot;小白&quot;</span>];</span><br><span class="line"><span class="comment">//  2 对象类型的数组</span></span><br><span class="line"><span class="keyword">let</span> pets3: <span class="built_in">Array</span>&lt;<span class="built_in">object</span>&gt; = [&#123; <span class="attr">name</span>: <span class="string">&quot;旺财&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;小白&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pets4: <span class="built_in">object</span>[] = [&#123; <span class="attr">name</span>: <span class="string">&quot;旺财&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;小白&quot;</span> &#125;];</span><br><span class="line"><span class="comment">//  3 数组中，随意放string、number、boolean类型 这里的 | 相当于 或 的意思 </span></span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">Array</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>&gt; = [<span class="string">&quot;hello swr&quot;</span>, <span class="number">28</span>];</span><br><span class="line"><span class="comment">//  4 想在数组中放任意类型</span></span><br><span class="line"><span class="keyword">let</span> arr2: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = [<span class="string">&quot;hello xxx&quot;</span>, <span class="number">208</span>, <span class="literal">true</span>]</span><br><span class="line"><span class="keyword">let</span> arr4: <span class="built_in">any</span>[] = [<span class="string">&quot;hello xxx&quot;</span>, <span class="number">208</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure>

<h2 id="元祖类型tuple"><a href="#元祖类型tuple" class="headerlink" title="元祖类型tuple"></a>元祖类型tuple</h2><p>元组类型必须一一对应上，多了少了或者类型不对都会报错。<br>元组类型是一个不可变的数组，长度、类型是不可变的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personT: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;某某某&#x27;</span>, <span class="number">28</span>]</span><br><span class="line"><span class="comment">// 有bug 增加不会报错，直接访问增加的元素会报错</span></span><br><span class="line">personT.push(<span class="string">&#x27;1245789&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(personT)  <span class="comment">//  [&#x27;某某某&#x27;, 28,&#x27;1245789]</span></span><br><span class="line"><span class="built_in">console</span>.log(personT[<span class="number">2</span>])  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>可以定义一些值，定义完了后可以直接拿来用了，用的时候也不会赋错值。并且不能再给枚举类型修改值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际项目中可以用来枚举订单状态等 </span></span><br><span class="line"><span class="built_in">enum</span> orderStatus &#123;</span><br><span class="line">    WAIT_FOR_PAY = <span class="string">&quot;待支付&quot;</span>,</span><br><span class="line">    UNDELIVERED = <span class="string">&quot;完成支付，待发货&quot;</span>,</span><br><span class="line">    DELIVERED = <span class="string">&quot;已发货&quot;</span>,</span><br><span class="line">    COMPLETED = <span class="string">&quot;已确认收货&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的枚举值是从0开始，如上述代码，red=0，green=1依次类推;</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  green,</span><br><span class="line">  red,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Color[<span class="number">0</span>]) <span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(Color[green]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>也可以修改默认的初始值，此时red=3, blue=4依次类推，但是red前面的枚举值是不会修改的</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color1 &#123;</span><br><span class="line">  green ,</span><br><span class="line">  red= <span class="number">3</span>,</span><br><span class="line">  blue,</span><br><span class="line">  orange,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Color1[<span class="number">0</span>]) <span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(Color1[<span class="number">1</span>]) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Color1[<span class="number">2</span>]) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Color1[<span class="number">4</span>]) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>若未定义接口声明的字段（非可选），则检查会抛出错误，传参中有接口未定义项也会报错<br>接口索引的key类型只能number或者string</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数或者方法实现接口的情况 */</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">  hostName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + person.firstName + <span class="string">&quot; &quot;</span> + person.lastName </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(greeter(&#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;h&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;ry&#x27;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类实现接口的情况 */</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPoint</span> <span class="title">implements</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">20</span></span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span> = <span class="number">30</span></span><br><span class="line">  <span class="attr">z</span>:<span class="built_in">number</span> = <span class="number">40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>any在TypeScript中是一个比较特殊的类型，声明为any类型的变量相当于放弃了类型检查 任何值都可以。对于any类型的变量，可以将其赋予任何类型的值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> power: <span class="built_in">any</span>;</span><br><span class="line">power = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">power = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// btn 有可能获取的到也有可能获取不到是null类型</span></span><br><span class="line"><span class="keyword">let</span> btn:<span class="built_in">any</span> = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">btn.style.color = <span class="string">&quot;blue&quot;</span></span><br><span class="line"><span class="comment">// 当然也有粗暴一些的方式，利用 ! 强制断言</span></span><br><span class="line"><span class="keyword">let</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>)</span><br><span class="line">btn1!.style!.color = <span class="string">&quot;blue&quot;</span></span><br></pre></td></tr></table></figure>
<p>any对于JS代码的迁移是十分友好的，在已经成型的TypeScript项目中，我们要慎用any类型，当你设置为any时，意味着告诉编辑器不要对它进行任何检查。</p>
<h2 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h2><p>null和undefined作为TypeScript的特殊类型，可以赋值给任意类型的变量：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">var</span> str: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值给任意类型的变量都是合法的</span></span><br><span class="line">num = <span class="literal">null</span>;</span><br><span class="line">str = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>void 类型一般是定义函数没有返回值。不 return  或者return undeifned ,其他类型的返回值会报错</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello1&quot;</span>, name)  <span class="comment">// 不return任何值没有问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>       <span class="comment">// return  undefined 也可以 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// say(&#x27;xiaoming&#x27;)  </span></span><br></pre></td></tr></table></figure>

<h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>never类型 永远不会有返回值 （很少用，用于抛出异常）<br>申明never类型的变量只能被never类型赋值(包括null和undefined)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x:<span class="literal">null</span> ;</span><br><span class="line">x = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> xx: <span class="built_in">never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line">error(<span class="string">&quot;error&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>也就是说，当一个函数执行的时候，被抛出异常打断了，导致没有返回值或者该函数是一个死循环，永远没有返回值，这样叫做永远不会有返回值。<br>实际开发中，是never和联合类型来一起用，比如</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say5</span>(<span class="params"></span>): (<span class="params"><span class="built_in">never</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">say5()</span><br></pre></td></tr></table></figure>

<h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h2><p>readonly是只读属性的修饰符，当我们的属性是只读时，可以用该修饰符加以约束，在类中，用readonly修饰的属性仅可以在构造函数中初始化：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">readonly</span> bar = <span class="number">1</span>; <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">readonly</span> baz: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.baz = <span class="string">&quot;hello&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个实用场景是在react中，props和state都是只读的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="keyword">readonly</span> foo: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">    <span class="keyword">readonly</span> bar: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">Props</span>,<span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">someMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.foo = <span class="number">123</span>; <span class="comment">// ERROR: (props are immutable)</span></span><br><span class="line">    <span class="built_in">this</span>.state.baz = <span class="number">456</span>; <span class="comment">// ERROR: (one should use this.setState)  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，React本身在类的声明时会对传入的props和state做一层ReadOnly的包裹，因此无论我们是否在外面显式声明，赋值给props和state的行为都是会报错的。</p>
<p>readonly和const区别：</p>
<ol>
<li>readonly是修饰属性的</li>
<li>const是声明变量的</li>
</ol>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数本身有参数类型和返回值类型，都可进行声明。<br>当函数没有返回值时，可以用void来表示。<br>当一个函数永远不会返回时，我们可以声明返回值类型为never<br>1 . 函数声明法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;run&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 . 变量赋值法/匿名函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>3 . 形参和实参要完全一样</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say7</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">say7(<span class="string">&quot;某某某&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>4 . 可选参数<br>形参和实参要完全一样，如想不一样，则需要配置可选参数，可选参数用 ？处理，只能放在后面</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say8</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line">say8(<span class="string">&quot;某某某&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>5 . 设置默认参数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, method: <span class="built_in">string</span> = <span class="string">&quot;GET&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(url, method)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6 . 设置剩余参数 利用扩展运算符</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, ...args: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args)  <span class="comment">// [2,3,4,5]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(args.join(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total:<span class="built_in">number</span> = sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>7 . 函数的重载 就是判断参数类型执行不同的逻辑   同名函数的问题，js中不存在函数的重载</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类内的成员有：字段、存取器、构造函数、方法。<br>1 . 存取器</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">age</span>(): <span class="title">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">age</span>(<span class="params">newName: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newName &gt; <span class="number">150</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>._age = <span class="number">150</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的get/set方法，就是_age变量的存取器。首先我们为_age变量添加一个private修饰符。表示它是个私有变量，禁止外部对它的访问。</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person._age <span class="comment">// 这句会报错，TS不允许我们读取私有变量。</span></span><br><span class="line"><span class="comment">// 要想使用_age，需要利用存取器：</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.age = <span class="number">15</span>; <span class="comment">// 使用set age方法</span></span><br><span class="line"><span class="keyword">const</span> age = pereson.age; <span class="comment">// 使用get age方法</span></span><br><span class="line"><span class="comment">// 使用存取器的好处是对变量的访问和设置，有了控制。原则上类内部的变量，外部是不能访问的，这就是封装性。要想访问，只能通过存取器方法。</span></span><br></pre></td></tr></table></figure>
<p>2 . 构造函数<br>constructor就是类的构造器，通过 new 命令创建对象实例时，自动调用该方法 返回实例对象 this ，<br>但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line">      <span class="function"><span class="title">constructor</span>(<span class="params">age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>._age = age;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。 super 这个关键字，既可以当做函数使用，也可以当做对象使用。<br>这两种情况下，它的用法完全不用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();  <span class="comment">// ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 . 定义一个类</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.name和this.age必须在前面先声明好类型</span></span><br><span class="line">    <span class="comment">// name:string   age:number</span></span><br><span class="line">    <span class="built_in">this</span>.name = name,</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 . 类的继承</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonX</span> </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name</span><br><span class="line">      <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  say(): <span class="built_in">string</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">PersonX</span> </span>&#123;</span><br><span class="line">  <span class="attr">childName</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, childName: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">    <span class="built_in">this</span>.childName = childName</span><br><span class="line">  &#125;</span><br><span class="line">  childSay(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.childName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child1(<span class="string">&#x27;某某某1&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child.say()) <span class="comment">//&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(child.childSay()) <span class="comment">// &#x27;某某某1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>5 . 类的修饰符<br>public公开的，可以供自己、子类以及其它类访问<br>protected受保护的，可以供自己、子类访问，但是其他就访问不了<br>private私有的，只有自己访问，而子类、其他都访问不了<br>6 . 抽象类 使用abstract 关键字</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实际上是使用了public修饰符</span></span><br><span class="line">  <span class="comment">// 如果添加private修饰符则会报错</span></span><br><span class="line">  <span class="keyword">abstract</span> eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要注意的是，这个Animal类是不能实例化的</span></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal() <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的抽象方法，意思就是，需要在继承这个抽象类的子类中实现这个抽象方法，不然会报错</span></span><br><span class="line"><span class="comment">// Person6 会报错，因为在子类Person6中没有实现eat抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person6</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">eat1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;吃米饭&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不会报错,因为Dog类中实现了抽象方法eat</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口主要是一种规范，规范对像，函数，数组，类必须遵守规范，<br>需要使用到关键字interface<br>1 . 接口规范对象<br>可以让多个方法使用这个规范<br>我们通过这样的方式，规范必须传name和age的值  多个接口都规范必须传name和age的值呢，每个方法都写就很重复</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> infoInterface &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">  city?: <span class="built_in">string</span> <span class="comment">// 该参数为可选参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">user: infoInterface</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 . 接口规范函数<br>对一个函数的参数和返回值进行规范</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> mytotal &#123;</span><br><span class="line">  <span class="comment">// 左侧是函数的参数，右侧是函数的返回类型</span></span><br><span class="line">  (a: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total: mytotal = <span class="function"><span class="keyword">function</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(total(<span class="number">10</span>,<span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<p>3 . 接口规范数组</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> userInterface &#123;</span><br><span class="line">  <span class="comment">// index为数组的索引，类型是number</span></span><br><span class="line">  <span class="comment">// 右边是数组里为字符串的数组成员</span></span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr: userInterface = [<span class="string">&#x27;规范数组&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>4 . 接口规范类</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先实现一个接口</span></span><br><span class="line"><span class="keyword">interface</span> Animal1 &#123;</span><br><span class="line">    <span class="comment">// 这个类必须有name</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="comment">// 这个类必须有eat方法</span></span><br><span class="line">    <span class="comment">// 规定eat方法的参数类型以及返回值类型</span></span><br><span class="line">    eat(<span class="built_in">any</span>: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增一个接口</span></span><br><span class="line"><span class="keyword">interface</span> Animal2 &#123;</span><br><span class="line">    sleep(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关键字 implements 实现</span></span><br><span class="line"><span class="comment">// 因为接口是抽象的，需要通过子类去实现它</span></span><br><span class="line"><span class="comment">// 可以在implements后面通过逗号添加，实现遵循多个接口，</span></span><br><span class="line"><span class="comment">// 一个类只能继承一个父类，但是却能遵循多个接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person9</span> <span class="title">implements</span> <span class="title">Animal1</span>, <span class="title">Animal2</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    eat(<span class="built_in">any</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`吃<span class="subst">$&#123;<span class="built_in">any</span>&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sleep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;睡觉&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 . 接口可以继承接口 就和类继承类一样的</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal3 &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    eat(<span class="built_in">any</span>: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 像类一样，通过extends继承</span></span><br><span class="line"><span class="keyword">interface</span> Animal4 <span class="keyword">extends</span> Animal3 &#123;</span><br><span class="line">    sleep(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为Animal4类继承了Animal3</span></span><br><span class="line"><span class="comment">// 所以这里遵循Animal4就相当于把Animal3也继承了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person10</span> <span class="title">implements</span> <span class="title">Animal4</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    eat(<span class="built_in">any</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`吃<span class="subst">$&#123;<span class="built_in">any</span>&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sleep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;睡觉&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有了接口为什么还需要抽象类？</strong><br>  接口里面只能放定义，抽象类里面可以放普通类、普通类的方法、定义抽象的东西。<br>  比如抽象类中有10个方法, 其中九个是实现过的方法, 只有一个是抽象的方法, 那么子类继承过来</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在一般化的场景，我们的类型可能并不固定已知，它和any有点像，只不过我们希望在any的基础上约束参数和返回值要保持一致性<br>1 . 类的泛型<br>使用 &lt; &gt; 跟在类名后面</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个私有属性</span></span><br><span class="line">    <span class="keyword">private</span> arr: T[] = []</span><br><span class="line">    <span class="comment">// 规定传参类型</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">value: T</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 规定返回值的类型</span></span><br><span class="line">    max():T&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,<span class="built_in">this</span>.arr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> class123 = <span class="keyword">new</span> MyMath&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;hell&#x27;</span>)<span class="comment">//实例化类，指定类的类型是string</span></span><br></pre></td></tr></table></figure>
<p>2 . 函数的泛型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toreturn = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = items.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        toreturn.push(items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toreturn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversed = reverse&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);<span class="comment">// 调用方法一</span></span><br><span class="line"><span class="keyword">var</span> reversed = reverse([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);        <span class="comment">//调用方法二</span></span><br></pre></td></tr></table></figure>
<p>3 . 接口的泛型<br><strong>写法一：</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 规范函数的接口的泛型</span></span><br><span class="line"><span class="keyword">interface</span> fnInt &#123;</span><br><span class="line">    &lt;T&gt; (value:T) : <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFn : fnInt = &lt;T&gt;(value : T) : <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`打印value:<span class="subst">$&#123;value&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newFn&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;119&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(newFn&lt;<span class="built_in">number</span>&gt;(<span class="number">120</span>))</span><br></pre></td></tr></table></figure>
<p><strong>写法二：</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ConfigFnTwo&lt;T&gt;&#123;</span><br><span class="line">    (value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDataTwo</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> setDataTwoFn:ConfigFnTwo&lt;<span class="built_in">string</span>&gt; = setDataTwo</span><br><span class="line">setDataTwoFn(<span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>在JS中，一个变量的类型可能是几种类型之一，使用一个|分割符来分割多种类型，这种复合类型，称之为联合类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatCommandline</span>(<span class="params">command: <span class="built_in">string</span>[]|<span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> line = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> command === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        line = command.trim();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        line = command.join(<span class="string">&#x27; &#x27;</span>).trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f11</span>(<span class="params">name : <span class="built_in">string</span>, age : <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(age.length)<span class="comment">//报错</span></span><br><span class="line"> &#125;</span><br><span class="line">f11(<span class="string">&#x27;ljy&#x27;</span>, <span class="string">&#x27;21&#x27;</span>)</span><br><span class="line"><span class="comment">// 报错,因为length 不是 string 和 number 的共有属性，所以会报错。所以只能访问类型的共有的属性或方法</span></span><br></pre></td></tr></table></figure>
<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>联合类型的语义类似于或者，交叉类型的语义类似于集合中的并集</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> DogInterface &#123;</span><br><span class="line">  run(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> CatInterface &#123;</span><br><span class="line">  jump(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pet: DogInterface &amp; CatInterface = &#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言可以用来手动指定一个值的类型。<br>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的：<br>类型断言有两种写法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params"><span class="keyword">type</span>:<span class="built_in">number</span>|<span class="built_in">string</span></span>):<span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">type</span> <span class="keyword">as</span> <span class="built_in">number</span>)&#123;  <span class="comment">// 第一种写法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">type</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params"><span class="keyword">type</span>:<span class="built_in">number</span>|<span class="built_in">string</span></span>):<span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(&lt;<span class="built_in">number</span>&gt;<span class="keyword">type</span>)&#123;  <span class="comment">// 第二种写法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">type</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Utility &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">Utility.log(<span class="string">&#x27;Call me&#x27;</span>);</span><br><span class="line">Utility.error(<span class="string">&#x27;maybe&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>待完成<br>ts声明文件 xxx.d.ts<br>global.d.ts 与 lib.d.ts 以及自定义*.d.ts<br>命名空间 声明空间<br>@types 环境声明<br>tsconfig.json 配置项<br>react 项目中配置ts（即支持jsx）<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5d8efeace51d45782b0c1bd6#heading-7">https://juejin.im/post/5d8efeace51d45782b0c1bd6#heading-7</a> ts场景，优缺点，vscode插件安利<br>ts社区 <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a></p>
<p>《TypeScript Deep Dive》 的中文翻译版  <a target="_blank" rel="noopener" href="https://jkchao.github.io/typescript-book-chinese/typings/types.html#%E4%BD%BF%E7%94%A8-types">https://jkchao.github.io/typescript-book-chinese/typings/types.html#%E4%BD%BF%E7%94%A8-types</a><br>global.d.ts 是一种扩充 lib.d.ts 很好的方式，如果你需要。<br>当你从 JS 迁移到 TS 时，定义 declare module “some-library-you-dont-care-to-get-defs-for” 能让你快速开始。</p>
<p><strong>typescript.json配置</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Basic Options */</span><span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="comment">// &quot;incremental&quot;: true,                   /* Enable incremental compilation */</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,    <span class="comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,    <span class="comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class="line">    <span class="comment">// &quot;lib&quot;: [],                            // 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;es6&quot;</span>, <span class="string">&quot;dom&quot;</span>],                            <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="comment">// &quot;allowJs&quot;: true,                      // 允许编译 javascript 文件</span></span><br><span class="line">    <span class="comment">// &quot;checkJs&quot;: true,                      // 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="comment">// &quot;jsx&quot;: &quot;preserve&quot;,                    // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">    <span class="comment">// &quot;declaration&quot;: true,                  // 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class="line">    <span class="comment">// &quot;declarationMap&quot;: true,               /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;sourceMap&quot;: true,                    // 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class="line">    <span class="comment">// &quot;outFile&quot;: &quot;./&quot;,                      // 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="comment">// &quot;outDir&quot;: &quot;./ts/dist/&quot;,               // 指定输出目录</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;../tsCompile/&quot;</span>, <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDir&quot;: &quot;./&quot;,                      // 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="comment">// &quot;composite&quot;: true,                     /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// &quot;tsBuildInfoFile&quot;: &quot;./&quot;,               /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,                  <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="comment">// &quot;noEmit&quot;: true,                       // 不生成输出文件</span></span><br><span class="line">    <span class="comment">// &quot;importHelpers&quot;: true,                // 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="comment">// &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;isolatedModules&quot;: true,              // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span><span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,                          <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitAny&quot;: true,                // 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="comment">// &quot;strictNullChecks&quot;: true,             // 启用严格的 null 检查</span></span><br><span class="line">    <span class="comment">// &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// &quot;strictBindCallApply&quot;: true,           /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span></span><br><span class="line">    <span class="comment">// &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitThis&quot;: true,               // 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="string">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>,                    <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span><span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="comment">// &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span><span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="comment">// &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="comment">// 上面的&quot;module&quot;: &quot;commonjs&quot;,则moduleResolution 默认为node</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="comment">// &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="comment">// &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="comment">// &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表</span></span><br><span class="line">    <span class="comment">// &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,     <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line">    <span class="string">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span> <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// &quot;allowUmdGlobalAccess&quot;: true,          /* Allow accessing UMD globals from modules. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="comment">// &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="comment">// &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="comment">// &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Experimental Options */</span> <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="comment">// &quot;experimentalDecorators&quot;: true,        // 启用装饰器</span></span><br><span class="line">    <span class="comment">// &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [ <span class="comment">/**要编译的文件*/</span></span><br><span class="line">    <span class="comment">// &quot;src/**/*&quot;</span></span><br><span class="line">    <span class="comment">// &quot;./ts/*.ts&quot;</span></span><br><span class="line">    <span class="string">&quot;./**/*&quot;</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// &quot;exclude&quot;: [   /** 忽略的文件*/</span></span><br><span class="line">  <span class="comment">//     &quot;node_modules&quot;,</span></span><br><span class="line">  <span class="comment">//     &quot;**/*.spec.ts&quot;</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/03/typescript/" data-id="cks2wselu000gcws5dfue12z6" data-title="typescript" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ReactAPI" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/03/ReactAPI/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T03:14:37.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/03/ReactAPI/">reactAPI</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h2><p>memo 用来对<strong>函数</strong>组件进行缓存，父组件传的props未改变时，不会重新渲染该子组件，与class组件的PureComponent类似，<br>默认情况下其只会对复杂对象做浅层对比，可以传递一个对比函数作为第二个参数，来进行深层次的对比。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击Re-render不会引起ReactMemo组件的重新渲染</span></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactMemo</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ReactMemo渲染了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;`我是props的值:$&#123;props.flag&#125;`&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> memo(ReactMemo)</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactMemo <span class="keyword">from</span> <span class="string">&#x27;../ReactMemo/ReactMemo&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [random, setRandom] = useState(<span class="built_in">Math</span>.random());</span><br><span class="line">  <span class="keyword">const</span> [mounted, setMounted] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 这个函数改变 random，并触发重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> reRender = <span class="function">() =&gt;</span> setRandom(<span class="built_in">Math</span>.random());</span><br><span class="line">  <span class="keyword">const</span> toggle = <span class="function">() =&gt;</span> setMounted(!mounted);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;reRender&#125;</span>&gt;</span>Re-render<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;toggle&#125;</span>&gt;</span>switch<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ReactMemo</span> <span class="attr">flag</span>=<span class="string">&#123;mounted&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">ReactMemo</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子组件接收方法的情况下，需要配合useCallback 将函数缓存才能真正做到子组件的缓存</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/03/ReactAPI/" data-id="cks2wself0001cws565h975i2" data-title="reactAPI" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ReactHooks" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/03/ReactHooks/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T03:11:45.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/03/ReactHooks/">reactHooks</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>副作用：React 中主要指那些没有发生在数据向视图（M-V）转换过程中的逻辑，如 Ajax 请求、访问原生 DOM 元素、本地持久化缓存、绑定/解绑事件、添加/取消订阅、设置定时器、记录日志等。</p>
<p>Hooks 的优越性：</p>
<ol>
<li>函数式编程：No class, No super, No this。对于不了解 OOP 的 React 初学者更友好。</li>
<li>有状态逻辑易复用：可以通过 Custom Hook（后面讲解）重构，而不用修改组件结构。</li>
<li>易拆分：状态管理和副作用管理松耦合，原子性强。很容易将一些相关联的逻辑拆分成更小的函数。</li>
<li>可逐步引入：Hooks 向后兼容，与现有代码可并行工作，因此我们可以逐步采用它们。</li>
<li>副作用分组：很多副作用逻辑分散在类组件生命周期函数中。而 Hooks 可以将每个副作用的设置和清理封装在一个函数中。</li>
<li>副作用分离：副作用操作都在页面渲染之后。</li>
</ol>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>useState用来声明状态变量。接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第[0]项是当前当前的状态值，第[1]项是可以改变状态值的方法函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果不用es6解构写法就得这么写：</span></span><br><span class="line"><span class="keyword">let</span> _useState = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> count = _useState[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> setCount = _useState[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p><strong>useState是按照书写顺序执行的</strong>，因此为了保证执行顺序一致。useState不能书写在if else 等判断逻辑中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">  <span class="keyword">const</span> [loading,setLoading] = useState(<span class="literal">false</span>)</span><br><span class="line">  flag = <span class="literal">true</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">const</span> [datalist,setDataList] = useState([])</span><br></pre></td></tr></table></figure>
<p><strong>useState「粒度」问题</strong><br>实际工作中，一个类组件的 this.state 中往往有十几项，用 Hooks 改写的话要写十几个 useState<br>根据官方文档，总结下来，有几点：</p>
<ol>
<li>建议将 state 分割为多个 useState。粒度更细，更易于管理，更好复用。</li>
<li>可能一起改变的 state 可合并成一个useState（ 比如Dom元素的 top left）。</li>
<li>当 state 逻辑趋于复杂，建议使用 reducer 或 Custom Hook 管理（后面介绍）。</li>
<li>当组件的 state 很多的时候，为了提高代码的可读性，也可以把逻辑相关的一些 state 合并为一个 useState（ 比如分页参数 ）。但这些 state 并不是一起改变的，所以当其中一个 state 改变，调用对应的 setFunction 的时候。你需要做对象合并(不合并就丢了)：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ pageData, setPageDate ] = useState(&#123; <span class="attr">pageSize</span>: <span class="number">20</span>, <span class="attr">current</span>: <span class="number">1</span>, <span class="attr">total</span>:<span class="number">0</span>, &#125;)</span><br><span class="line"><span class="keyword">const</span> onPageChange = <span class="function"><span class="params">current</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 常规操作</span></span><br><span class="line">  setPageDate( <span class="built_in">Object</span>.assign( &#123;&#125;, pageData, &#123; current &#125; ) ）</span><br><span class="line">  <span class="comment">// 官方建议</span></span><br><span class="line">  setPageDate(<span class="function"><span class="params">currentPageData</span> =&gt;</span> (&#123; ...currentPageData, current&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect在第一次渲染之后和每次更新之后都会执行。也可以通过第二个参数来控制是否执行，<strong>React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</strong><br>effects 的心理模型跟 componentDidMount 和其他的生命周期是不同的。<strong>应该用 effects 的方式去思考</strong>，而且比起回应生命周期事件，它的心理模型更接近於<strong>執行同步化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 组件卸载之前执行 需要做副作用的清理，保证引起不必要内存泄漏。比如，手动绑定事件，订阅，定时器等。</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;,[]);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState,useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`mount:<span class="subst">$&#123;count&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`unmount:<span class="subst">$&#123;count&#125;</span>`</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I&#x27;m a lifecycle demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setCount(count + 1)&#125;&#125;&gt;add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;count&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// home组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState,useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./Home.scss&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;../Child/Child&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 建立一个状态来切换 LifecycleDemo 的显示和隐藏</span></span><br><span class="line">  <span class="keyword">const</span> [mounted, setMounted] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 该函数将卸载并重新挂载 LifecycleDemo</span></span><br><span class="line">  <span class="comment">// 在控制台可以看到  unmount 被打印 </span></span><br><span class="line">  <span class="keyword">const</span> toggle = <span class="function">() =&gt;</span> setMounted(!mounted);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;toggle&#125;</span>&gt;</span>Show/Hide LifecycleDemo<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;mounted &amp;&amp; <span class="tag">&lt;<span class="name">Child</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>控制useEffect 的执行</strong><br>useEffect(fn, []),第二个参数是个数组，传递的是该useEffect的依赖项。<br>当传递进去的依赖项变动时，该useEffect会重新执行。<br>注意：</p>
<ol>
<li>不传第二个参数，则其他不相关数据变动引起的组件重新渲染时也会重新执行该useEffect；</li>
<li>第二个参数为空数组，表示没有依赖项，该useEffect在组件首次渲染时执行和组件卸载时执行清除副作用之后就不会再执行，（诚实传递依赖项，不要漏写，以免引起未知问题）；</li>
</ol>
<p><strong>与 componentDidMount 和 componentDidUpdate 的区别</strong><br>使用 useEffect 调度的副作用不会阻塞浏览器更新屏幕。这使得应用感觉上具有响应式。大多数副作用不需要同步发生。如果需要同步进行，（比如测量布局），有一个单独的 useLayoutEffect Hook， API 和 useEffect 相同。</p>
<p><strong>知识点</strong>：调用 useState 的更新函数时，可以传一个箭头函数，这个函数的参数是当前最新的 state， 返回值是要设置的 state,可以配合useEffect使用，来减少useEffect的依赖项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 秒表开关</span></span><br><span class="line">  <span class="keyword">const</span> [isOn, setIsOn] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// 计数</span></span><br><span class="line">  <span class="keyword">const</span> [timer, setTimer] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> interval;</span><br><span class="line">    <span class="comment">//开关打开的时候才执行</span></span><br><span class="line">    <span class="keyword">if</span> (isOn) &#123;</span><br><span class="line">      <span class="comment">// 通过定时器增加计数</span></span><br><span class="line">      interval = <span class="built_in">setInterval</span>(</span><br><span class="line">        <span class="function">() =&gt;</span> setTimer(timer + <span class="number">1</span>), <span class="comment">// 这里每次需要获取定时器每次的最新值，所以这种写法，useEffect必须添加timer为依赖项</span></span><br><span class="line">        <span class="comment">// () =&gt; setTimer(val =&gt; val + 1),// 用箭头函数的方式，参数就是最新的定时器值，这种写法可以减少依赖项，较优</span></span><br><span class="line">        <span class="number">1000</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要清除定时器</span></span><br><span class="line">    <span class="comment">// 不清理会如何？codesandbox中尝试，页面直接卡死</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;,[isOn,timer]); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;timer&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;!isOn &amp;&amp; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setIsOn(true)&#125;&gt;</span></span><br><span class="line"><span class="xml">          Start</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">      &#123;isOn &amp;&amp; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setIsOn(false)&#125;&gt;</span></span><br><span class="line"><span class="xml">          Stop</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p><strong>实际项目中axios的使用</strong><br>useEffect 不能接收 async 作为执行函数。useEffect 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 async 返回的是 promise。<br>useEffect 调用的函数如果依赖 state 或者 props。最好在执行函数中定义。这样依赖容易追踪。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState([]);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 更优雅的方式</span></span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">      );</span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      ))&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>多级嵌套组件之间共享状态，可以使用useContext。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">age</span>:<span class="number">118</span>,</span><br><span class="line">  <span class="attr">action</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is action&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dataContext = React.createContext(data.age);  <span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ContextCo</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (                                          <span class="comment">// 2.</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">dataContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;data.age&#125;</span>&gt;</span>         </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dataContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">GraSon</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">GraSon</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GraSon</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = useContext(dataContext);            <span class="comment">// 3.</span></span><br><span class="line">  <span class="built_in">console</span>.log(data)   <span class="comment">//  118</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      this is GraSon</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>useRef 不仅仅是用来管理 DOM ref 的(场景一)，同时也会用来存放组件实例的属性（场景三）。<br>useRef 返回一个可变的ref对象，其.current属性被初始化为传入的参数（initialValue）。<strong>返回的 ref 对象在组件的整个生命周期内保持不变,是相同的引用</strong>（createRef 每次渲染都会返回一个新的引用）,因此 <strong>useRef 的内容发生变化时,它不会通知您</strong>。更改.current属性不会导致重新呈现。 因为他一直是一个引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景一：</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">      inputEl.current.focus();  <span class="comment">// input框聚焦</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>useRef可以获取到实时状态</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景二：点击lert按钮时的count值，是点击alert动作触发时的count值快照，不是定时器触发后的实时值，</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState,useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>计时器 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setCount(count + 1)&#125;&#125;&gt;add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;log&#125;</span>&gt;</span>print<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述场景如何取到定时器触发时实时的状态？ 需要使用uesRef</span></span><br><span class="line"><span class="comment">// 场景三：</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> latestCount = useRef(count)</span><br><span class="line">  useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    latestCount.current = count </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(latestCount.current);</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>计时器 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setCount(count + 1)&#125;&#125;&gt;add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;log&#125;</span>&gt;</span>print<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>useMemo返回的是数据，用来缓存数据，当 组件内部某一个渲染的数据，需要通过计算而来，这个计算是依赖与特定的state、props数据，我们就用useMemo来缓存这个数据，以至于我们在修改她们没有依赖的数据源的情况下，多次调用这个计算函数，浪费计算资源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useRef, useMemo,useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ReactUseCallback</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [gender,setGender] = useState(<span class="string">&#x27;male&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> latestCount = useRef(count)</span><br><span class="line">  useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    latestCount.current = count </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> log = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(latestCount.current);</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">judgeGender</span>(<span class="params">gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这里是判断性别的方法&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> gender === <span class="string">&#x27;male&#x27;</span> ? <span class="string">&quot;男&quot;</span>:<span class="string">&quot;女&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// let showGender = judgeGender(gender)  // 这种写法，count修改时，judgeGender方法也会重复调用</span></span><br><span class="line">  <span class="keyword">let</span> showGender = useMemo(<span class="function">()=&gt;</span>&#123;   <span class="comment">// 依赖项gender不改变则不会重复执行judgeGender方法</span></span><br><span class="line">    <span class="keyword">return</span> judgeGender(gender)</span><br><span class="line">  &#125;,[gender])</span><br><span class="line">  <span class="keyword">const</span> change = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是父组件传递的方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>计时器 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setCount(count + 1)&#125;&#125;&gt;add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前次数：&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;log&#125;</span>&gt;</span>print<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setGender(&#x27;female&#x27;)&#125;&gt;修改性别<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里显示性别：&#123;showGender&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>缓存一个函数，这个函数如果是由父组件传递给子组件，或者自定义hooks里面的函数【通常自定义hooks里面的函数，不会依赖于引用它的组件里面的数据】，这时候我们可以考虑缓存这个函数，好处：</p>
<p>1，不用每次重新声明新的函数，避免释放内存、分配内存的计算资源浪费<br>2，子组件不会因为这个函数的变动重新渲染。(和React.memo搭配使用)</p>
<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><h2 id="Custom-Hooks"><a href="#Custom-Hooks" class="headerlink" title="Custom Hooks"></a>Custom Hooks</h2><p>自定义 Hook 是一个 JavaScript 函数，其名称以 ”use” 开头，可以调用其他 Hook<br><strong>Custom Hooks 将解决有状态（stateful）逻辑共享的问题（相当于类组件中Hoc的功能）</strong><br>下面是判断设备是否离线的自定义hook:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// 自定义 hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOffline</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOffline, setIsOffline] = useState(<span class="built_in">window</span>.navigator.onLine);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onOffline</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setIsOffline(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onOnline</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setIsOffline(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;offline&#x27;</span>, onOffline);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;online&#x27;</span>, onOnline);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;offline&#x27;</span>, onOffline);</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;online&#x27;</span>, onOnline);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> isOffline; <span class="comment">// 只暴露一个 state</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOffline = useOffline();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">       &#123; </span></span><br><span class="line"><span class="xml">         isOffline</span></span><br><span class="line"><span class="xml">         ? <span class="tag">&lt;<span class="name">div</span>&gt;</span>网断已断开 ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">         : <span class="tag">&lt;<span class="name">div</span>&gt;</span>网络已连接 ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">       &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/03/ReactHooks/" data-id="cks2wselb0000cws59zsy9gal" data-title="reactHooks" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-nginx" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/22/nginx/" class="article-date">
  <time class="dt-published" datetime="2019-12-22T02:26:23.000Z" itemprop="datePublished">2019-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/12/22/nginx/">nginx</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向代理是指客户端与目标服务器之间增加一个代理服务器，客户端直接访问代理服务器，在由代理服务器访问目标服务器并返回客户端并返回 。这个过程当中客户端需要知道代理服务器地址，并配置连接。</p>
<h1 id="反向代理的概念"><a href="#反向代理的概念" class="headerlink" title="反向代理的概念"></a>反向代理的概念</h1><p>反向代理是指 客户端访问目标服务器，在目标服务内部有一个统一接入网关将请求转发至后端真正处理的服务器并返回结果。这个过程当中客户端不需要知道代理服务器地址，代理对客户端而言是透明的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/12/22/nginx/" data-id="cks2wselp000acws5h8imarjt" data-title="nginx" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/react/" style="font-size: 20px;">react</a> <a href="/tags/typescript/" style="font-size: 10px;">typescript</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/02/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/">javascript 原型链</a>
          </li>
        
          <li>
            <a href="/2021/08/02/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/03/08/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">发布-订阅模式</a>
          </li>
        
          <li>
            <a href="/2020/05/03/linux%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C/">linux文件路径操作</a>
          </li>
        
          <li>
            <a href="/2020/05/03/typescript/">typescript</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>