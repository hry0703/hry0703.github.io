---
title: 浏览器EventLoop
date: 2021-5-21 19:48:44
tags:
---

### 浏览器的事件环

#### 进程

计算机分配任务的 和调度的任务最小单位， 浏览器是一个多进程模型， 每个页卡都是一个独立的进程 （更稳定）

#### 线程

线程是 CPU调度的最小单位
一个进程可以包括多个线程，这些线程共享这个进程的资源

#### chrome浏览器进程

* 浏览器是多进程的
* 每一个TAB页就是一个进程
* 浏览器主进程
  * 控制其它子进程的创建和销毁
  * 浏览器界面显示，比如用户交互、前进、后退等操作
  * 将渲染的内容绘制到用户界面上
* 渲染进程就是我们说的浏览器内核
  * 负责页面的渲染、脚本执行、事件处理
  * 每个TAB页都有一个渲染进程
* 网络进程 处理网络请求、文件访问等操作
* GPU进程 用于3D绘制
* 第三方插件进程

#### 渲染进程

* GUI渲染线程
  * 渲染、布局和绘制页面
  * 当页面需要重绘和回流时，此线程就会执行
  * 与JS引擎互斥
* JS引擎线程
  * 负责解析执行JS脚本
  * 只有一个JS引擎线程(单线程)
  * 与GUI渲染线程互斥
* 事件触发线程
  * 用来控制事件循环(鼠标点击、setTimeout、Ajax等)
  * 当事件满足触发条件时，把事件放入到JS引擎所有的执行队列中
* 定时器触发线程
  * setInterval和setTimeout所在线程
  * 定时任务并不是由JS引擎计时，而是由定时触发线程来计时的
  * 计时完毕后会通知事件触发线程
* 异步HTTP请求线程
  * 浏览器有一个单独的线程处理AJAX请求
  * 当请求完毕后，如果有回调函数，会通知事件触发线程

#### 执行过程

![执行过程示意图](/images/eventloop.png)

1. 先执行script脚本，将宏任务和微任务进行分类，如果调用的是浏览器api ，浏览器会开一个线程，等时间到了，会自动的放入到宏任务队列中,微任务是直接放到微任务队列中的
2. js执行完毕后，会清空所有的微任务，如果微任务在产生微任务，会放到当前微任务队列的尾部
3. 如果页面需要渲染，则会执行渲染流程

 事件触发线程会不停的扫描宏任务队列，如果宏任务队列中有对应的回调，会取出来执行一个，继续执行上述过程
 宏任务每次调用一个，微任务是请空所有

 微任务队列每次执行宏任务 都会创造一个新的队列，宏任务队列只有一个



 **宏任务**
<执行脚本 script> UI / setTimeout / setInterval / setImmediate /  事件 ajax  / MessageChannel  (I/O)

**微任务**
promise，MutationObserer,object.observe  (process.nextTick)  queueMircotask

```javascript
Promise.resolve().then(data=>{
    console.log('promise1')
    Promise.resolve().then(data=>{
        console.log('promise2')
    })
})
setTimeout(() => {
    console.log('setimeout')
}, 0);
```